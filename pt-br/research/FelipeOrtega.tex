\chapterwithauthor{Felipe Ortega}{Prepare-se para o futuro: evolução de equipes em Software Livre}

\authorbio{Felipe Ortega é pesquisador e gerente de projetos no Libresoft, um grupo
de pesquisa na Universidade Rey Juan Carlos (URJC), Espanha. Felipe desenvolve novas
metodologias para analisar comunidades colaborativas abertas (como projetos de Software
Livre, Wikipedia e redes sociais). Ele fez uma extensa pesquisa com o projeto
Wikipedia e sua comunidade de autores. Ele participa ativamente na pesquisa,
promoção e educação/treinamento em Software Livre, especialmente no Mestrado
em Software Livre da URJC. É um defensor ferrenho dos recursos educacionais abertos,
acesso aberto em publicações científicas e dados abertos na ciência.}

\noindent{}Em seu famoso ensaio \textit{A catedral e o bazar}\footnote{\url{
http://www.catb.org/~esr/writings/cathedral-bazaar/cathedral-bazaar}.}, Eric S.
Raymond menciona uma das primeiras lições importantes que todo programador 
deve aprender: "todo bom trabalho de software começa por motivações pessoais 
do desenvolvedor". Você nunca percebe quão correta é essa afirmação até você mesmo
enfrentar essa situação. Na verdade, a maioria dos programadores de Software Livre
(senão todos) certamente passaram por esse processo à medida em que começaram
a trabalhar em um novo projeto ou se juntaram a um já existente, ansiosos por ajudar
a torná-lo melhor. Entretanto, muitos desenvolvedores e outros participantes de 
comunidades de Software Livre (escritores de documentação, tradutores, etc) geralmente
negligenciam outra importante lição enfatizada por Raymond em seu ensaio: "quando você perde
interesse em um programa, a sua última obrigação é entregá-lo a um sucessor competente".
Esse é o tema central que eu gostaria de abordar aqui. Você deveria pensar sobre o futuro
de seu projeto e sobre os novatos que um dia assumirão o seu trabalho e continuarão
a melhorá-lo.

\section*{Alternância de gerações}

Em algum momento de suas vidas, muitos projetos de Software Livre vão enfrentar
uma alternância de gerações. Os antigos desenvolvedores -- responsáveis pela manutenção
e melhoria do código-fonte -- eventualmente deixarão o projeto e sua comunidade, por diversas razões.
Tais razões incluem questões pessoais, um novo emprego que não lhes deixa tempo livre suficiente, o início de um novo projeto,
a mudança para um projeto diferente aparentemente mais atrativo, \dots\ A lista pode ser bastante longa.

O estudo da alternância de gerações (ou rotatividade do desenvolvedor) em projetos de Software Livre
ainda é uma área de estudos emergente e que requer mais pesquisas para melhorar nossa
compreensão dessas situações. Apesar disso, alguns pesquisadores já coletaram evidências
objetivas que lança alguma luz sobre esses processos.
No OSS 2006, meus colegas Jesus G. Barahona e Gregorio Robles apresentaram um trabalho
intitulado "Contributor Turnover in Libre Software Projects". Nesse trabalho,
eles mostram uma metodologia para identificar os desenvolvedores mais ativos (geralmente conhecidos
como \textit {core contributors}) em diferentes intervalos de tempo, ao longo de toda a história
de um dado projeto. Então, eles aplicam este método para estudar 21 grandes projetos, em
particular o GIMP, o Mozilla (antiga instância do famoso navegador) e
o Evolution. Em resumo, o que eles descobriram é que nós podemos identificar três tipos de
projetos de acordo com sua taxa de rotatividade de desenvolvedores:
\begin{itemize}
 \item Projetos com única geração: aqueles que dependem fortemente do trabalho de seus 
fundadores e há muito pouca ou nenhuma alternância de gerações. O GIMP se
enquadra nessa categoria.
 \item Projetos com múltiplas gerações: projetos como o Mozilla apresentam um claro
padrão de rotatividade de desenvolvedores, com novos grupos de desenvolvedores
ativos assumindo a liderança da manutenção e desenvolvimento do código das mãos
dos \textit {core contributors} anteriores.
 \item Projetos compostos: o Evolution pertence a uma terceira categoria de projetos,
apresentando alguma taxa de rotatividade mas não tão evidente como no caso anterior,
atenuado pela retenção de alguns \textit {core contributors} ao longo da história do
projeto.
\end{itemize}

Essa classificação nos leva a uma pergunta óbvia: qual é o padrão mais
comum encontrado em projetos reais de Software Livre? Bem, os resultados
para um conjunto total de 21 projetos analisados no trabalho de Barahona \& Robles levam a uma clara conclusão:
múltiplas gerações e projetos compostos são os casos mais comuns no ecossistema
do Software Livre. Somente o Gnumeric e o Mono mostraram um padrão distinto de forte retenção
de desenvolvedores antigos, indicando que as pessoam que contribuem para estes projetos podem 
ter razões mais atraentes para continuar seu trabalho por um longo tempo.

No entanto, este não é o cenário normal. Pelo contrário, este estudo fornece
apoio para o conselho que estamos considerando aqui: que deveríamos nos
preparar para transferir, em algum momento no futuro, nosso papel e conhecimento no
projeto para os futuros contribuidores que vão se juntar à nossa comunidade.

\section*{A lacuna do conhecimento}

Qualquer pessoa que experimenta uma mudança significativa em sua vida deve lidar
com a adaptação a novas condições. Por exemplo, quando você deixa o seu trabalho
por um outro você se prepara para um certo período no qual você tem que se ajustar
ao novo lugar e se integrar a um grupo de trabalho diferente. Felizmente, depois de
um tempo você finalmente se estabelece em seu novo emprego. Mas, às vezes, você
mantém bons amigos do seu antigo emprego e pode encontrá-los novamente após
a mudança. Talvez, então, conversando com seus ex-colegas de trabalho, você pode saber
o que aconteceu com a pessoa contratada para ocupar sua antiga posição. Isso raramente ocorre em
projetos de Software Livre.

A desvantagem da alternância de gerações em projetos de Software Livre pode
vir em uma forma muito concreta: a lacuna de conhecimento. Quando uma
antiga desenvolvedora deixa o projeto -- e especialmente se ela teve uma vasta experiência
na comunidade em questão -- ela deixa para trás conhecimentos tangíveis e abstratos,
que podem ou não ser passados aos novatos subsequentes.

Um exemplo claro é o código-fonte. Como qualquer produto de trabalho intelectual sofisticado
(bem, ao menos deve-se esperar isso, certo?) os desenvolvedores deixam uma marca
pessoal sempre que produzem um novo código. Algumas vezes, você se sente eternamente
em débito com aquele programador incrível que escreveu aquele código claro e elegante, que praticamente
fala por si só e é fácil de manter. Outras vezes, a situação é o oposto e você luta
para entender aquele código obscuro e confuso, sem qualquer comentário ou dica
que possa ajudá-lo.

Foi isso o que tentamos medir em 2009, em um trabalho de pesquisa apresentado no HICSS
2009. O título é "Using Software Archeology to Measure Knowledge Loss in
Software Projects Due to Developer Turnover". Caso você esteja se perguntando, isso não
tem nada a ver com chicotes, tesouros, templos ou aventuras emocionantes, embora
tenha sido realmente divertido. O que medimos (entre outras coisas) foi a porcentagem
de código orfão que foi deixado para trás por desenvolvedores que sairam de projetos de Software
Livre e que não foi assumido por nenhum desenvolvedor atual. Neste caso,
escolhemos quatro projetos (Evolution, GIMP, Evince e Nautilus) para testar nosso método
de pesquisa. Nós encontramos resultados muito interessantes.

O Evolution apresentou um padrão de certa forma preocupante, no sentido que a porcentagem
dos códigos orfãos estava crescendo ao longo do tempo. Até 2006, quase 80\% de todas as
linhas de código-fonte tinham sido abandonadas pelos antigos desenvolvedores e permaneciam
intocadas pelo resto da equipe. Por outro lado, o GIMP apresentou um padrão radicalmente
diferente, com um esforço claro e sustentado da equipe de desenvolvimento para reduzir o
número de linhas de código orfãs. A propósito, lembre-se que o GIMP já tinha sido caracterizado
como um projeto com única geração e, assim, se beneficia de uma equipe de desenvolvimento
muito mais estável para realizar esta difícil tarefa.

Isto significa que os desenvolvedores do GIMP tiveram uma melhor experiência que
a equipe do Evolution? Para ser honesto, nós não sabemos. Entretanto, podemos antever um
risco claro e previsível: quanto maior a porcentagem de código orfão, maior o esforço para
manter o projeto. Sempre que você precisar corrigir um \textit {bug}, desenvolver uma
nova funcionalidade ou ampliar uma já existente, você se depara com um código que nunca tinha
visto antes. Claro que você pode ser um programador fantástico mas, independente de quão maravilhoso
você seja, os desenvolvedores do GIMP têm uma clara vantagem neste caso, já que eles têm alguém
na equipe com o conhecimento preciso sobre a maior parte do código que eles precisam manter.
Além disso, eles também trabalham para reduzir ainda mais a parte desconhecida do código-fonte.

\section*{É como sentir-se em casa}

Curiosamente, alguns projetos conseguem reter usuários por períodos muito maiores
que o esperado. Mais uma vez, podemos encontrar evidência empírica para suportar essa 
afirmação. No OSS 2005, Michlmayr, Robles e González-Barahona apresentaram alguns
resultados relevantes sobre este aspecto. Eles estudaram a persistência da participação
de mantenedores de software no Debian, calculando a chamada taxa de meia-vida. 
Esse é o tempo necessário para que uma determinada população de mantenedores caia pela
metade do seu tamanho inicial. O resultado foi que a meia-vida estimada dos mantenedores
do Debian é de aproximadamente 7.5 anos. Em outras palavras, visto que o estudo
foi realizado durante um período de seis anos e meio (entre julho de 1998 e
dezembro de 2004) -- abrangendo do Debian 2.0 ao Debian 3.1 (somente versões estáveis) -- 
mais de 50\% dos mantenedores do Debian 2.0 ainda estavam contribuindo no Debian
3.1.

O Debian criou um procedimento bastante formal para admitir novos mantenedores de
software (também conhecidos como desenvolvedores Debian) incluindo a aceitação do
Contrato Social do Debian e a demonstração de familiaridade com a Política do Debian.
Como resultado, seria óbvia a presença de contribuidores bastante comprometidos. E foi 
exatamente o que aconteceu, visto que percebeu-se que pacotes abandonados por antigos
mantenedores eram geralmente assumidos pelos desenvolvedores que permaneciam na
comunidade. Um pacote era simplesmente abandonado apenas naqueles casos em que não era mais útil.
Acho que podemos aprender algumas lições úteis a partir destes trabalhos de pesquisa:
\begin{enumerate}
 \item Gaste algum tempo desenvolvendo as diretrizes principais do seu projeto. Elas
 podem começar como um documento único e pequeno, simplesmente apresentando algumas
 recomendações e boas práticas. Isso deve evoluir à medida em que o projeto cresce,
 passando a funcionar como uma pílula de aprendizagem para que novatos rapidamente compreendam 
 os valores centrais da sua equipe, bem como os principais traços de seu estilo de trabalho.
 \item Obrigue-se a seguir padronizações de código bem estabelecidos, boas práticas e
estilos elegantes. Documente seu código. Inclua comentários para descrever seções que
podem ser especialmente difíceis de entender. Não ache que você está desperdiçando
seu tempo. Na prática, você está sendo bastante pragmático, investindo tempo no futuro
do seu projeto.
 \item Se possível, quando chegar a hora de você sair do projeto, tente deixar aos
 outros cientes da sua decisão com alguma antecedência. Certifique-se que eles entendam
 quais partes críticas irão precisar de um novo mantenedor. Idealmente, se vocês são 
 uma comunidade, prepare ao menos um procedimento simples para automatizar
 este processo e certifique-se que você não esqueceu nenhum ponto importante
 antes que uma determinada pessoa deixe o projeto (especialmente se ela for um desenvolvedor importante).
 \item Fique de olho na quantidade de código órfão. Se ele cresce rápido demais ou se
 atinge uma parte significativa do seu projeto, isto é uma indicação clara de que você terá
 problemas muito em breve, especialmente se o número de relatórios de \textit{bugs} cresce ou
 se você pretende corrigir o seu código com um refatoramento importante.
 \item Lembre-se sempre de deixar dicas e sugestões suficientes para um novato
 assumir o seu trabalho no futuro.
\end{enumerate}

\section*{Eu gostaria de saber que você estava vindo (antes de eu sair)}

Eu admito que não é muito fácil pensar em seus sucessores enquanto você está programando. 
Muitas vezes, você simplesmente não percebe que o seu código pode acabar sendo tomado por um
outro projeto, reutilizado por outros contribuidores ou que você pode, eventualmente, ser substituído
por outra pessoa, disposta a continuar o seu trabalho. No entanto, o bem mais precioso do
Software Livre é precisamente este: o código será reutilizado, adaptado, integrado ou ampliado
por outra pessoa. Manutenibilidade é uma característica fundamental da engenharia de software,
mas ela se torna fundamental no Software Livre. Não diz respeito apenas a código-fonte, 
mas também a pessoas, relações sociais e etiqueta digital. É algo além do simples bom gosto.
\textit{Quod severis metes} ("você colhe o que plantou"). Lembre-se disso na próxima vez, você
pode ser o novato preenchendo a lacuna de conhecimento deixada por um antigo desenvolvedor.
